# Initialise connection to the tcp server
import socket
import networkx as nx
from networkx.drawing.nx_agraph import graphviz_layout, to_agraph
from networkx.drawing.nx_pydot import write_dot, to_pydot
from networkx.exception import NetworkXNoPath
from modules.node import Node
import logging
from pprint import pprint

class TcpServer:
    def __init__(self):
        # define the host IP address and port
        self.host = '20.211.33.233'
        self.port = 65432

        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client_socket.connect((self.host, self.port))
        self.graph = nx.MultiDiGraph()

        
        # keep track of incomplete and completed nodes
        self.incomplete_nodes = {} 
        self.completed_nodes = {}

    def send_message(self, message: str) -> str:
        """
        Sends message to the TCP server. "\\n" character will be added to the message automatically

        Parameters
        ----------
        message : str
            The message that will be sent to the TCP server
        """
        message = f'{message}\n'
        self.client_socket.sendto(message.encode('utf-8'), (self.host, self.port))
        return self.client_socket.recv(1024).decode('utf-8').strip()
    

    def draw_visualisation(self, output_pic_name: str):
        """
        Function to draw graph with graphviz because graph visualisation generated by 
        Networkx isn't as good as the one generated by graphviz library
        
        Parameters
        -----------
        graph
            Networkx graph object
        
        Returns
        -------
        None
            function displays the generated pydot graph, doesn't return anything
        """
        pdot = to_pydot(self.graph)
        pdot.write_png(f'{output_pic_name}.png')
    
    def __move_to_nearest_incomplete_node(self, origin_node: Node):
			  
		# obtain shortest path between origin_node and all 'incomplete_nodes'
		# (if there's any)
        incomplete_node_distances = []
        for destination_label in self.incomplete_nodes.keys():
            try:
                shortest_path = nx.shortest_path(self.graph, origin_node.label, destination_label)
            except NetworkXNoPath:
                logging.debug(f'no path found between [{origin_node.label}] and [{destination_label}]')
                continue
            incomplete_node_distances.append((shortest_path, len(shortest_path)))

        if len(incomplete_node_distances) > 0:
			
			# Get the nearest incomplete node and the shortest path the program can take to reach that incomplete node
            incomplete_node_distances.sort(key=lambda shortest_path: shortest_path[1], reverse=False)
            logging.debug(f'incomplete_node_distances from [{origin_node.label}] is {incomplete_node_distances}')
            nearest_incomplete_node_path = incomplete_node_distances[0][0]
            logging.debug(f'nearest_incomplete_node_path is {nearest_incomplete_node_path}')

			# navigate the server to the next incomplete node by following the calculated
			# 'nearest_cinomplete_node_path'
            dest_index = 1
            while dest_index < len(nearest_incomplete_node_path):
                origin_label = nearest_incomplete_node_path[dest_index - 1]
                dest_label = nearest_incomplete_node_path[dest_index]
                if origin_label == 'Z' and dest_label == 'A':
                    dest_index += 1
                    continue
                action = self.graph.get_edge_data(origin_label, dest_label)[0]['label']
                self.send_message(action)
                dest_index += 1

			# return the next node as a 'Node' object
            logging.debug(f'moved to {dest_label}')
            return self.incomplete_nodes.get(dest_label)
        else:
            return None
        
    def get_server_structure(self):
        initial_node = Node(self.send_message("1"), self)
        self.graph.add_edge('Z', initial_node.label) 
        self.incomplete_nodes[initial_node.label] = initial_node

        origin_node = initial_node

        while self.incomplete_nodes:
            if action := origin_node.get_next_possible_action():
                logging.debug('INCOMPLETE NODES')
                pprint(self.incomplete_nodes)
                logging.debug('COMPLETED NODES')
                pprint(self.completed_nodes)

                destination_label = origin_node.move_to_next_node(action)
                if destination_label != 'Z':
                    if self.incomplete_nodes.get(destination_label):
                        destination_node = self.incomplete_nodes[destination_label]
                    elif self.completed_nodes.get(destination_label):
                        destination_node = self.completed_nodes.get(destination_label)
                    else:
                        logging.debug(f'A new destination node with label [{destination_label}] is found')
                        destination_node = Node(destination_label, self)
                        self.incomplete_nodes[destination_label] = destination_node
                else:
                    destination_node = initial_node

                logging.debug(f'{origin_node.label}----{action}---->{destination_node.label}')
                
                if origin_node.get_next_possible_action() == None:
                    self.incomplete_nodes.pop(origin_node.label)
                    self.completed_nodes[origin_node.label] = origin_node

                origin_node = destination_node
            else:

                # navigate to the nearest incomplete node
                if next_node := self.__move_to_nearest_incomplete_node(origin_node):
                    origin_node = next_node 
                else:
                    break